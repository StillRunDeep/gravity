<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>万有引力与时空曲面模拟</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            pointer-events: none;
            border-radius: 5px;
        }
    </style>
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info">
        <h3>万有引力曲面模拟</h3>
        <p>黄色：大质量天体 (Sun)<br>蓝色：环绕天体 (Planet)</p>
        <p>网格根据引力势能实时弯曲</p>
    </div>

    <script>
        // --- 1. 初始化场景 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 20, 100);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 40);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 鼠标控制
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 2. 物理参数定义 ---
        const G = 2; // 引力常数 (为了视觉效果调整过)
        
        // 中心天体 (太阳)
        const sun = {
            mass: 500,
            radius: 2,
            pos: new THREE.Vector3(0, 0, 0),
            mesh: null
        };

        // 环绕小球 (行星)
        const planet = {
            mass: 1,
            radius: 0.5,
            pos: new THREE.Vector3(12, 0, 0),
            vel: new THREE.Vector3(0, 0, 5), // 初始切向速度
            mesh: null,
            trail: [] // 轨迹
        };

        // 计算初始速度以保证近似圆形轨道 (v = sqrt(GM/r))
        // 这里的 r 是 12.
        const perfectVelocity = Math.sqrt((G * sun.mass) / planet.pos.distanceTo(sun.pos));
        // 给一点偏心率，让它变成椭圆
        planet.vel.set(0, 0, perfectVelocity * 0.85);

        // --- 3. 创建物体 ---

        // 创建太阳
        const sunGeo = new THREE.SphereGeometry(sun.radius, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd00, emissive: 0xffaa00 });
        sun.mesh = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sun.mesh);

        // 创建行星
        const planetGeo = new THREE.SphereGeometry(planet.radius, 16, 16);
        const planetMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        planet.mesh = new THREE.Mesh(planetGeo, planetMat);
        scene.add(planet.mesh);

        // 创建轨迹线
        const trailMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
        const trailGeometry = new THREE.BufferGeometry();
        const trailLine = new THREE.Line(trailGeometry, trailMaterial);
        scene.add(trailLine);


        // --- 4. 创建可变形的网格 (曲面) ---
        // 这是一个平面，细分数越高越平滑，但性能消耗越大
        const gridSize = 60;
        const gridSegments = 60;
        const planeGeo = new THREE.PlaneGeometry(gridSize, gridSize, gridSegments, gridSegments);
        
        // 旋转平面使其水平
        planeGeo.rotateX(-Math.PI / 2);

        // 保存原始顶点位置，用于每帧重置
        const originalPositions = [];
        const posAttribute = planeGeo.attributes.position;
        for (let i = 0; i < posAttribute.count; i++) {
            originalPositions.push({
                x: posAttribute.getX(i),
                y: posAttribute.getY(i),
                z: posAttribute.getZ(i)
            });
        }

        const planeMat = new THREE.MeshBasicMaterial({ 
            color: 0x444444, 
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        scene.add(plane);


        // --- 5. 核心逻辑循环 ---

        function animate() {
            requestAnimationFrame(animate);

            // A. 物理计算 (万有引力)
            // r 向量
            const dt = 0.05; // 时间步长
            const distVector = new THREE.Vector3().subVectors(sun.pos, planet.pos);
            const dist = distVector.length();
            
            // F = G * M * m / r^2
            // 防止距离过近导致除以零爆炸，加个小常数
            const forceMagnitude = (G * sun.mass * planet.mass) / (dist * dist);
            
            // 力向量 = 方向 * 大小
            const force = distVector.normalize().multiplyScalar(forceMagnitude);
            
            // a = F / m
            const acceleration = force.clone().divideScalar(planet.mass);
            
            // 更新速度 v = v + a * dt
            planet.vel.add(acceleration.multiplyScalar(dt));
            
            // 更新位置 p = p + v * dt
            planet.pos.add(planet.vel.clone().multiplyScalar(dt));

            // 同步模型位置
            planet.mesh.position.copy(planet.pos);
            
            // 简单的轨迹绘制逻辑
            if (planet.trail.length > 300) planet.trail.shift(); // 限制轨迹长度
            planet.trail.push(planet.pos.clone());
            
            // 更新轨迹几何体
            const points = planet.trail;
            trailGeometry.setFromPoints(points);


            // B. 更新网格曲面 (模拟引力势井)
            // 这是一个视觉效果：离物体越近，网格越向下凹陷
            const positions = plane.geometry.attributes.position;
            
            for (let i = 0; i < positions.count; i++) {
                const ox = originalPositions[i].x;
                const oz = originalPositions[i].z;
                
                // 计算顶点到太阳的距离
                const distToSun = Math.sqrt((ox - sun.pos.x)**2 + (oz - sun.pos.z)**2);
                
                // 计算顶点到行星的距离
                const distToPlanet = Math.sqrt((ox - planet.pos.x)**2 + (oz - planet.pos.z)**2);

                // 变形公式: y = - Mass / (Distance + Softening)
                // 太阳造成的凹陷
                let depSun = - (sun.mass * 0.15) / (distToSun + 2); // 系数是为了视觉调整
                // 行星造成的凹陷 (小一点)
                let depPlanet = - (planet.mass * 5) / (distToPlanet + 0.5);

                const newY = depSun + depPlanet;

                positions.setY(i, newY);
            }
            
            // 告诉 Three.js 顶点更新了
            positions.needsUpdate = true;

            // C. 渲染
            controls.update();
            renderer.render(scene, camera);
        }

        // 窗口大小改变适应
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate();
    </script>
</body>
</html>