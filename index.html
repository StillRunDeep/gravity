<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>万有引力：曲面与投影模拟</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: #fff; font-family: 'Segoe UI', sans-serif; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            padding: 15px;
            pointer-events: none;
            border-radius: 8px;
            max-width: 300px;
            width: calc(100% - 70px);
            box-sizing: border-box;
        }
        h3 { margin: 0 0 10px 0; color: #00ffff; font-size: 1.1em; }
        p { margin: 5px 0; font-size: 14px; color: #ccc; }
        .highlight { color: #ffff00; font-weight: bold; }
        
        /* 移动端适配按钮容器 */
        .btn-group {
            margin-top: 15px;
            pointer-events: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .action-btn {
            padding: 6px 12px;
            cursor: pointer;
            background: #222;
            color: #fff;
            border: 1px solid #666;
            border-radius: 4px;
            font-size: 13px;
            flex: 1 1 calc(50% - 4px); /* 在移动端两列排布 */
            text-align: center;
            box-sizing: border-box;
            white-space: nowrap;
        }

        .action-btn:hover { background: #333; }
        .action-btn:active { background: #555; }

        @media (min-width: 600px) {
            .action-btn { flex: 1 1 auto; } /* 在宽屏自适应宽度 */
        }
    </style>
    <!-- 引入 Three.js -->
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
</head>
<body>
    <script>
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            var errInfo = document.createElement('div');
            errInfo.style.position = 'absolute';
            errInfo.style.zIndex = '9999';
            errInfo.style.background = 'rgba(255,0,0,0.8)';
            errInfo.style.color = 'white';
            errInfo.style.padding = '20px';
            errInfo.style.top = '10px';
            errInfo.style.right = '10px';
            errInfo.innerHTML = '<h3>JS Error:</h3><p>' + msg + '</p><p>Line: ' + lineNo + '</p>';
            document.body.appendChild(errInfo);
            return false;
        };
    </script>
    <div id="info">
        <div id="infoHeader" style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; pointer-events: auto; margin-bottom: 10px;">
            <h3 style="margin: 0;">时空曲率与引力模拟</h3>
            <span id="toggleIcon" style="font-size: 20px; font-weight: bold; line-height: 1;">−</span>
        </div>
        <div id="infoContent">
            <p><span class="highlight">黄色</span>：恒星 (Sun)</p>
            <p><span style="color:#00ffff; font-weight:bold;">多色</span>：行星 (Planets)</p>
            <p><span style="color:#aaaaaa; font-weight:bold;">灰色</span>：网格投影球 (Shadow)</p>
            <p>网格展示了引力场造成的时空弯曲。</p>
            <p><i>拖动鼠标旋转视角，滚轮缩放</i></p>
            
            <div style="margin-top: 10px; margin-bottom: 5px; pointer-events: auto;">
                <label for="dragSlider" style="font-size: 13px; color: #ccc; display: flex; justify-content: space-between;">
                    <span>轨道衰减强度:</span>
                    <span id="dragValue">0%</span>
                </label>
                <input type="range" id="dragSlider" min="0" max="100" step="1" value="0" style="width: 100%; margin-top: 5px;">
            </div>

            <div class="btn-group">
                <button id="addPlanetBtn" class="action-btn">添加随机行星</button>
                <button id="resetBtn" class="action-btn">重置为一个</button>
                <button id="toggleGridBtn" class="action-btn">隐藏网格</button>
                <button id="togglePlanetGravityBtn" class="action-btn">显示行星重力坑</button>
            </div>
        </div>
    </div>

    <script>
        // 控制面板收起展开逻辑
        document.getElementById('infoHeader').addEventListener('click', () => {
            const content = document.getElementById('infoContent');
            const icon = document.getElementById('toggleIcon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.innerText = '−';
            } else {
                content.style.display = 'none';
                icon.innerText = '+';
            }
        });

        // --- 1. 初始化场景 ---
        const scene = new THREE.Scene();
        // 添加一点背景雾效，增加深邃感
        scene.fog = new THREE.FogExp2(0x050505, 0.005);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 50); // 抬高视角
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 2. 物理参数 ---
        const G = 2; 
        const TIME_STEP = 0.05;

        // 恒星
        const sun = {
            mass: 500,
            radius: 2.5,
            pos: new THREE.Vector3(0, 0, 0),
            mesh: null
        };

        // --- 3. 创建太阳 ---
        const sunGeo = new THREE.SphereGeometry(sun.radius, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        const sunGlowSize = sun.radius * 1.2;
        const sunGlowGeo = new THREE.SphereGeometry(sunGlowSize, 32, 32);
        const sunGlowMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.3 });
        
        sun.mesh = new THREE.Mesh(sunGeo, sunMat);
        const sunGlow = new THREE.Mesh(sunGlowGeo, sunGlowMat);
        scene.add(sun.mesh);
        scene.add(sunGlow);

        // --- 4. 行星管理 ---
        let planets = [];

        function addPlanet(isInitial = false) {
            const mass = isInitial ? 1 : 0.5 + Math.random() * 2;
            const radius = 0.8 * Math.cbrt(mass);
            
            // 随机距离和角度
            const distance = isInitial ? 14 : 10 + Math.random() * 25;
            const angle = isInitial ? 0 : Math.random() * Math.PI * 2;
            const pos = new THREE.Vector3(Math.cos(angle) * distance, 0, -Math.sin(angle) * distance);
            
            // 随机颜色
            const color = isInitial ? 0x00ffff : new THREE.Color().setHSL(Math.random(), 0.8, 0.5).getHex();
            
            // 行星网格
            const planetGeo = new THREE.SphereGeometry(radius, 24, 24);
            const planetMat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(planetGeo, planetMat);
            mesh.position.copy(pos);
            scene.add(mesh);
            
            // 初始速度
            const vel = new THREE.Vector3();
            const vCircle = Math.sqrt((G * sun.mass) / distance);
            // 偏心率随机
            const vMag = isInitial ? vCircle * 0.9 : vCircle * (0.7 + Math.random() * 0.5);
            // 速度方向垂直于半径方向
            vel.set(Math.sin(angle) * vMag, 0, Math.cos(angle) * vMag);
            
            // 轨迹线
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({ vertexColors: true, opacity: 1.0, transparent: true, linewidth: 2, blending: THREE.AdditiveBlending, depthWrite: false });
            const trailLine = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trailLine);
            
            // 投影小球
            const shadowGeo = new THREE.SphereGeometry(radius, 16, 16);
            const shadowMat = new THREE.MeshBasicMaterial({ color: 0x888888, wireframe: true, transparent: true, opacity: 0.6 });
            const shadowBall = new THREE.Mesh(shadowGeo, shadowMat);
            scene.add(shadowBall);

            // 投影轨迹线
            const shadowTrailGeometry = new THREE.BufferGeometry();
            const shadowTrailMaterial = new THREE.LineBasicMaterial({ vertexColors: true, opacity: 0.8, transparent: true, linewidth: 2, blending: THREE.AdditiveBlending, depthWrite: false });
            const shadowTrailLine = new THREE.Line(shadowTrailGeometry, shadowTrailMaterial);
            scene.add(shadowTrailLine);
            
            // 连线
            const connectorGeo = new THREE.BufferGeometry();
            connectorGeo.setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
            const connectorMat = new THREE.LineDashedMaterial({ color: 0x555555, dashSize: 1, gapSize: 0.5 });
            const connectorLine = new THREE.Line(connectorGeo, connectorMat);
            connectorLine.computeLineDistances();
            scene.add(connectorLine);
            
            planets.push({
                mass, radius, pos, vel, mesh, color, trail: [], trailLine, shadowBall, shadowTrail: [], shadowTrailLine, connectorLine, connectorGeo, insideSunTime: 0
            });
        }

        function clearPlanets() {
            for (let p of planets) {
                scene.remove(p.mesh);
                scene.remove(p.trailLine);
                scene.remove(p.shadowBall);
                scene.remove(p.shadowTrailLine);
                scene.remove(p.connectorLine);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
                p.trailLine.geometry.dispose();
                p.trailLine.material.dispose();
                p.shadowBall.geometry.dispose();
                p.shadowBall.material.dispose();
                p.shadowTrailLine.geometry.dispose();
                p.shadowTrailLine.material.dispose();
                p.connectorLine.geometry.dispose();
                p.connectorLine.material.dispose();
            }
            planets = [];
        }

        // 初始化第一个行星
        addPlanet(true);

        // 按钮事件
        document.getElementById('addPlanetBtn').addEventListener('click', () => {
            addPlanet(false);
        });
        document.getElementById('resetBtn').addEventListener('click', () => {
            clearPlanets();
            addPlanet(true);
        });

        // --- 5. 创建 "加粗" 曲面网格 ---
        const gridSize = 80;
        const gridSegments = 80; // 增加密度以获得更平滑的弯曲
        const planeGeo = new THREE.PlaneGeometry(gridSize, gridSize, gridSegments, gridSegments);
        planeGeo.rotateX(-Math.PI / 2); // 旋转至水平

        // 保存原始顶点数据
        const originalPositions = [];
        const posAttr = planeGeo.attributes.position;
        for(let i=0; i<posAttr.count; i++){
            originalPositions.push({
                x: posAttr.getX(i),
                z: posAttr.getZ(i)
            });
        }

        const wireMat = new THREE.MeshBasicMaterial({ color: 0x004488, wireframe: true, transparent: true, opacity: 0.4 });
        const solidMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.8, side: THREE.DoubleSide });

        const planeWire = new THREE.Mesh(planeGeo, wireMat);
        const planeSolid = new THREE.Mesh(planeGeo, solidMat);
        planeSolid.position.y = -0.05; 
        
        scene.add(planeWire);
        scene.add(planeSolid);

        // 网格显示/隐藏逻辑
        let gridVisible = true;
        document.getElementById('toggleGridBtn').addEventListener('click', (e) => {
            gridVisible = !gridVisible;
            planeWire.visible = gridVisible;
            planeSolid.visible = gridVisible;
            e.target.innerText = gridVisible ? '隐藏网格' : '显示网格';
        });

        // 行星重力坑显示/隐藏逻辑
        let planetGravityEnabled = false;
        document.getElementById('togglePlanetGravityBtn').addEventListener('click', (e) => {
            planetGravityEnabled = !planetGravityEnabled;
            e.target.innerText = planetGravityEnabled ? '隐藏行星重力坑' : '显示行星重力坑';
        });

        // 阻力系数逻辑
        let dragCoefficient = 0;
        const dragSlider = document.getElementById('dragSlider');
        const dragValueDisplay = document.getElementById('dragValue');
        
        dragSlider.addEventListener('input', (e) => {
            const sliderValue = parseFloat(e.target.value);
            // 将 0-100 映射到 0-0.001
            dragCoefficient = (sliderValue / 100) * 0.001;
            dragValueDisplay.innerText = sliderValue + '%';
        });

        // --- 6. 辅助函数：计算某一点的 Y 轴凹陷深度 ---
        function calculateGridY(x, z) {
            const distSun = Math.sqrt((x - sun.pos.x)**2 + (z - sun.pos.z)**2);
            let dep = - (sun.mass * 0.2) / (distSun + 2.5);
            
            if (planetGravityEnabled) {
                for (let p of planets) {
                    const distPlanet = Math.sqrt((x - p.pos.x)**2 + (z - p.pos.z)**2);
                    dep -= (p.mass * 6) / (distPlanet + 0.6);
                }
            }
            return dep;
        }

        // --- 7. 动画循环 ---
        // 辅助函数：更新轨迹线顶点颜色（实现渐隐效果）
        function updateTrailColors(geometry, baseColorHex, length) {
            if (length === 0) return;
            const colors = new Float32Array(length * 3);
            const baseColor = new THREE.Color(baseColorHex);
            const bgColor = new THREE.Color(0x050505); // 雾/背景色
            for (let i = 0; i < length; i++) {
                const ratio = i / (length - 1 || 1);
                // 使用平方缓动让尾部变暗更快，头部更亮
                const easeRatio = ratio * ratio; 
                const c = bgColor.clone().lerp(baseColor, easeRatio);
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        }

        function animate() {
            requestAnimationFrame(animate);

            // 处理坠入太阳的行星 (延迟销毁)
            for (let i = planets.length - 1; i >= 0; i--) {
                const p = planets[i];
                const distVec = new THREE.Vector3().subVectors(sun.pos, p.pos);
                
                // 完全进入太阳内部：两球心距离加上行星自身半径必须小于太阳的半径
                if (distVec.length() + p.radius <= sun.radius) {
                    // 累计在太阳内部的时间
                    p.insideSunTime += TIME_STEP;
                    
                    // 如果超过约 2 秒 (根据 TIME_STEP 换算，假设 60fps)
                    // TIME_STEP 这里是 0.05，现实的 1 帧大约是 16ms。
                    // 2秒大约是 120帧。累计的物理时间: 120 * 0.05 = 6.0
                    // 为了更准确使用实际时间，我们假设 requestAnimationFrame 稳定在 60Hz
                    // 所以 2秒 = 120帧，这里给个阈值 6.0 左右的物理累加时间，或者直接用帧数计数
                } else {
                    // 如果中途飞出去了，重置计时器
                    p.insideSunTime = 0;
                }

                // 这里我们假设 TIME_STEP=0.05 对应一帧，2秒(120帧)的话 time = 6.0
                if (p.insideSunTime >= 6.0) {
                    // 销毁并移除
                    scene.remove(p.mesh, p.trailLine, p.shadowBall, p.shadowTrailLine, p.connectorLine);
                    p.mesh.geometry.dispose(); p.mesh.material.dispose();
                    p.trailLine.geometry.dispose(); p.trailLine.material.dispose();
                    p.shadowBall.geometry.dispose(); p.shadowBall.material.dispose();
                    p.shadowTrailLine.geometry.dispose(); p.shadowTrailLine.material.dispose();
                    p.connectorLine.geometry.dispose(); p.connectorLine.material.dispose();
                    planets.splice(i, 1);
                }
            }

            for (let p of planets) {
                // 物理计算
                const distVec = new THREE.Vector3().subVectors(sun.pos, p.pos);
                const r = distVec.length();
                
                // F = G*M*m / r^2
                const F = (G * sun.mass * p.mass) / (r * r);
                const forceVec = distVec.normalize().multiplyScalar(F);
                
                const acc = forceVec.divideScalar(p.mass);
                p.vel.add(acc.multiplyScalar(TIME_STEP));

                // 应用空间阻力
                if (dragCoefficient > 0) {
                    p.vel.multiplyScalar(1 - dragCoefficient);
                }

                p.pos.add(p.vel.clone().multiplyScalar(TIME_STEP));
                
                p.mesh.position.copy(p.pos);

                // 更新投影小球位置
                const shadowX = p.pos.x;
                const shadowZ = p.pos.z;
                const distSun = Math.sqrt((shadowX - sun.pos.x)**2 + (shadowZ - sun.pos.z)**2);
                const shadowY = - (sun.mass * 0.2) / (distSun + 2.5);
                
                p.shadowBall.position.set(shadowX, shadowY, shadowZ);

                // 更新连线
                const connPoints = [p.pos, p.shadowBall.position];
                p.connectorGeo.setFromPoints(connPoints);
                p.connectorLine.computeLineDistances();

                // 更新轨迹
                if(p.trail.length > 600) p.trail.shift();
                p.trail.push(p.pos.clone());
                p.trailLine.geometry.setFromPoints(p.trail);
                updateTrailColors(p.trailLine.geometry, p.color, p.trail.length);

                // 更新投影轨迹
                if(p.shadowTrail.length > 600) p.shadowTrail.shift();
                p.shadowTrail.push(p.shadowBall.position.clone());
                p.shadowTrailLine.geometry.setFromPoints(p.shadowTrail);
                updateTrailColors(p.shadowTrailLine.geometry, 0xffffff, p.shadowTrail.length);
            }

            // 更新网格顶点 (只有在网格可见时才更新，优化性能)
            if (gridVisible) {
                const positions = planeGeo.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const ox = originalPositions[i].x;
                    const oz = originalPositions[i].z;
                    const newY = calculateGridY(ox, oz);
                    positions.setY(i, newY);
                }
                positions.needsUpdate = true;
            }
            
            // 太阳发光层简单脉动效果
            const time = Date.now() * 0.001;
            sunGlow.scale.setScalar(1 + Math.sin(time * 2) * 0.05);

            controls.update();
            renderer.render(scene, camera);
        }

        // 窗口适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>